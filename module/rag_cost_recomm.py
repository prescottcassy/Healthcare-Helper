# -*- coding: utf-8 -*-
"""Untitled39.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MKWi2TPTtRC3qO8FwQOF-Og0Jrd2gW6p
"""

"""
This module implements the three core components:
1. Vector Database for RAG
2. Cost Comparison Engine
3. Recommendation Logic
"""
import numpy as np
import pandas as pd
from typing import List, Dict, Any, Tuple, Optional
import chromadb
from chromadb.config import Settings
import sqlite3
from dataclasses import dataclass
from datetime import datetime
import json
import logging
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import re

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class HealthcareProcedure:
    """Data class for healthcare procedures"""
    cpt_code: str
    procedure_name: str
    base_cost: float
    provider_id: str
    provider_name: str
    location: str
    specialty: str
    insurance_accepted: List[str]
    quality_rating: float = 4.0

@dataclass
class InsurancePlan:
    """Data class for insurance plans"""
    plan_id: str
    plan_name: str
    deductible: float
    copay: Dict[str, float]  # procedure_type -> copay amount
    coinsurance: float
    out_of_pocket_max: float
    network_providers: List[str]

@dataclass
class PatientInfo:
    """Data class for patient information"""
    patient_id: str
    insurance_plan: Optional[InsurancePlan]
    location: str
    deductible_remaining: float
    out_of_pocket_remaining: float

class HealthcareVectorDatabase:
    """
    Vector database implementation for healthcare data using ChromaDB
    Stores and retrieves healthcare procedures, providers, and costs
    """

    def __init__(self, persist_directory: str = "./healthcare_vectordb"):
        """Initialize the vector database"""
        self.client = chromadb.PersistentClient(path=persist_directory)
        self.procedures_collection = self.client.get_or_create_collection(
            name="healthcare_procedures",
            metadata={"description": "Healthcare procedures and costs"}
        )
        self.providers_collection = self.client.get_or_create_collection(
            name="healthcare_providers",
            metadata={"description": "Healthcare providers and networks"}
        )
        logger.info("Vector database initialized")

    def add_procedures(self, procedures: List[HealthcareProcedure]):
        """Add healthcare procedures to the vector database"""
        documents = []
        metadatas = []
        ids = []

        for i, proc in enumerate(procedures):
            # Create searchable text combining procedure details - ENHANCED FOR BETTER MATCHING
            base_text = f"{proc.procedure_name} {proc.cpt_code} {proc.specialty}"

            # Add specific keywords for better matching
            keywords = []
            proc_name_lower = proc.procedure_name.lower()

            if "mri" in proc_name_lower or "imaging" in proc.provider_name.lower():
                keywords.extend(["MRI", "brain scan", "imaging", "radiology", "scan", "magnetic resonance"])
            elif "arthroscopy" in proc_name_lower or "knee" in proc_name_lower:
                keywords.extend(["knee surgery", "arthroscopy", "orthopedic", "joint surgery", "knee operation"])
            elif "visit" in proc_name_lower or "evaluation" in proc_name_lower:
                keywords.extend(["checkup", "visit", "consultation", "examination", "routine checkup", "physical"])
            elif "panel" in proc_name_lower or "lab" in proc.provider_name.lower():
                keywords.extend(["blood work", "laboratory", "lab tests", "blood tests", "lab panel", "blood draw"])
            elif "wellness" in proc_name_lower:
                keywords.extend(["wellness", "annual", "physical", "checkup", "preventive", "routine"])
            elif "dental" in proc.specialty.lower():
                keywords.extend(["dental", "teeth", "oral", "dentist"])

            # Combine base text with keywords
            doc_text = f"{base_text} {' '.join(keywords)}"
            documents.append(doc_text)

            # Store metadata for retrieval
            metadata = {
                "cpt_code": proc.cpt_code,
                "procedure_name": proc.procedure_name,
                "base_cost": proc.base_cost,
                "provider_id": proc.provider_id,
                "provider_name": proc.provider_name,
                "location": proc.location,
                "specialty": proc.specialty,
                "insurance_accepted": json.dumps(proc.insurance_accepted),
                "quality_rating": proc.quality_rating
            }
            metadatas.append(metadata)
            ids.append(f"proc_{proc.cpt_code}_{proc.provider_id}")

        # Add procedures to vector database
        self.procedures_collection.add(
            documents=documents,
            metadatas=metadatas,
            ids=ids
        )

        # Debug: Print what we're adding
        for i, (doc, meta) in enumerate(zip(documents[:3], metadatas[:3])):
            logger.info(f"Added procedure {i}: {doc} -> {meta['procedure_name']}")

        logger.info(f"Added {len(procedures)} procedures to vector database")

    def search_procedures(self, query: str, location: Optional[str] = None,
                         insurance_plan: Optional[str] = None, n_results: int = 10) -> List[Dict]:
        """Search for procedures using natural language query"""
        # Enhance query with location and insurance if provided
        enhanced_query = query
        if location:
            enhanced_query += f" {location}"

        # Search in vector database
        results = self.procedures_collection.query(
            query_texts=[enhanced_query],
            n_results=n_results,
            include=["metadatas", "documents", "distances"]
        )

        # Debug: Print search results
        logger.info(f"Search query: '{enhanced_query}'")
        logger.info(f"Found {len(results['ids'][0])} results")

        # Process and filter results
        processed_results = []
        # Check if results and required subfields are not None
        if (
            results is not None and
            results.get('ids') is not None and
            results.get('metadatas') is not None and
            results.get('distances') is not None and
            results['ids'] and results['metadatas'] and results['distances']
        ):
            for i in range(len(results['ids'][0])):
                metadata = results['metadatas'][0][i]
                distance = results['distances'][0][i]

                logger.info(f"Result {i}: {metadata['procedure_name']} (distance: {distance:.3f})")

                # Filter by insurance if specified
                if insurance_plan:
                    insurance_accepted_value = metadata['insurance_accepted']
                    if not isinstance(insurance_accepted_value, str):
                        insurance_accepted_value = str(insurance_accepted_value)
                    accepted_plans = json.loads(insurance_accepted_value)
                    if insurance_plan not in accepted_plans:
                        continue

                # Filter by location if specified
                if location:
                    provider_location = metadata.get('location', '')
                    if not isinstance(provider_location, str):
                        provider_location = str(provider_location)
                    if location.lower() not in provider_location.lower():
                        continue

                # Calculate proper relevance score (distance to similarity conversion)
                distance = results['distances'][0][i]
                # Convert distance to similarity: closer distance = higher similarity
                # Typical ChromaDB distances range from 0 to 2, so we normalize
                relevance = max(0, 1 - (distance / 2.0))  # Normalize to 0-1 range

                processed_results.append({
                    'cpt_code': metadata['cpt_code'],
                    'procedure_name': metadata['procedure_name'],
                    'base_cost': float(metadata['base_cost']) if metadata['base_cost'] is not None else 0.0,  # Ensure float conversion and handle None
                    'provider_id': metadata['provider_id'],  # Add missing provider_id
                    'provider_name': metadata['provider_name'],
                    'location': metadata['location'],
                    'specialty': metadata['specialty'],
                    'quality_rating': float(metadata['quality_rating']) if metadata['quality_rating'] is not None else 0.0,  # Ensure float conversion and handle None
                    'relevance_score': relevance  # Now properly normalized
                })
        else:
            logger.warning("No results returned from vector database or results are None.")
            # No results to process; processed_results will remain empty.

        return processed_results

class CostComparisonEngine:
    """
    Cost comparison engine that calculates and compares healthcare costs
    across different providers, insurance plans, and payment scenarios
    """

    def __init__(self, vector_db: HealthcareVectorDatabase):
        self.vector_db = vector_db
        self.insurance_multipliers = {
            'in_network': 0.7,  # 30% discount for in-network
            'out_of_network': 1.2,  # 20% surcharge for out-of-network
            'no_insurance': 1.0  # Full price
        }
        logger.info("Cost comparison engine initialized")

    def calculate_patient_cost(self, procedure: Dict, patient: PatientInfo) -> Dict[str, float]:
        """Calculate the actual cost a patient will pay for a procedure"""
        base_cost = procedure['base_cost']

        # If no insurance, return full cost
        if not patient.insurance_plan:
            return {
                'total_cost': base_cost,
                'insurance_covers': 0.0,
                'patient_pays': base_cost,
                'deductible_applied': 0.0,
                'copay_applied': 0.0,
                'coinsurance_applied': 0.0
            }

        plan = patient.insurance_plan

        # Determine if provider is in network
        is_in_network = procedure.get('provider_id') in plan.network_providers
        network_multiplier = self.insurance_multipliers['in_network'] if is_in_network else self.insurance_multipliers['out_of_network']

        # Calculate negotiated rate
        negotiated_rate = base_cost * network_multiplier

        # Apply copay if applicable
        procedure_type = procedure.get('specialty', 'general')
        copay = plan.copay.get(procedure_type, plan.copay.get('general', 0))

        # Calculate deductible application
        deductible_applied = min(negotiated_rate, patient.deductible_remaining)
        remaining_cost = negotiated_rate - deductible_applied

        # Calculate coinsurance on remaining cost
        coinsurance_applied = remaining_cost * plan.coinsurance if remaining_cost > 0 else 0

        # Total patient cost
        patient_cost = copay + deductible_applied + coinsurance_applied

        # Apply out-of-pocket maximum
        patient_cost = min(patient_cost, patient.out_of_pocket_remaining)

        return {
            'total_cost': negotiated_rate,
            'insurance_covers': negotiated_rate - patient_cost,
            'patient_pays': patient_cost,
            'deductible_applied': deductible_applied,
            'copay_applied': copay,
            'coinsurance_applied': coinsurance_applied,
            'is_in_network': is_in_network
        }

    def compare_costs(self, query: str, patient: PatientInfo, location: Optional[str] = None) -> List[Dict]:
        """Compare costs across multiple providers for a given procedure"""
        # Search for relevant procedures
        procedures = self.vector_db.search_procedures(
            query=query,
            location=location,
            n_results=20
        )

        # Calculate costs for each procedure
        cost_comparisons = []
        for proc in procedures:
            cost_breakdown = self.calculate_patient_cost(proc, patient)

            comparison_data = {
                **proc,
                **cost_breakdown,
                'savings_potential': 0.0  # Will be calculated after sorting
            }
            cost_comparisons.append(comparison_data)

        # Sort by patient cost
        cost_comparisons.sort(key=lambda x: x['patient_pays'])

        # Calculate savings potential compared to most expensive option
        if cost_comparisons:
            max_cost = max(comp['patient_pays'] for comp in cost_comparisons)
            for comp in cost_comparisons:
                comp['savings_potential'] = max_cost - comp['patient_pays']

        return cost_comparisons

    def generate_cost_summary(self, comparisons: List[Dict]) -> Dict:
        """Generate a summary of cost comparison results"""
        if not comparisons:
            return {"error": "No procedures found"}

        costs = [comp['patient_pays'] for comp in comparisons]

        return {
            'total_options': len(comparisons),
            'lowest_cost': min(costs),
            'highest_cost': max(costs),
            'average_cost': np.mean(costs),
            'potential_savings': max(costs) - min(costs),
            'cheapest_provider': comparisons[0]['provider_name'],
            'most_expensive_provider': comparisons[-1]['provider_name']
        }

class RecommendationEngine:
    """
    Recommendation engine that suggests optimal healthcare choices
    based on cost, quality, location, and patient preferences
    """

    def __init__(self, cost_engine: CostComparisonEngine):
        self.cost_engine = cost_engine
        self.recommendation_weights = {
            'cost': 0.4,
            'quality': 0.3,
            'distance': 0.2,
            'insurance_network': 0.1
        }
        logger.info("Recommendation engine initialized")

    def calculate_distance_score(self, patient_location: str, provider_location: str) -> float:
        """
        Calculate a simple distance score (in a real implementation,
        this would use actual geocoding and distance calculation)
        """
        # Simplified distance scoring based on string similarity
        if patient_location.lower() in provider_location.lower():
            return 1.0
        elif any(word in provider_location.lower() for word in patient_location.lower().split()):
            return 0.7
        else:
            return 0.3

    def score_recommendation(self, procedure: Dict, patient: PatientInfo) -> float:
        """Calculate a recommendation score for a procedure"""
        # RELEVANCE SHOULD BE THE PRIMARY FACTOR!
        relevance_score = max(0, procedure.get('relevance_score', 0))  # Ensure non-negative

        # Cost score (lower cost = higher score)
        max_reasonable_cost = 5000  # More reasonable maximum
        cost_score = max(0, (max_reasonable_cost - procedure['patient_pays']) / max_reasonable_cost)

        # Quality score (normalize to 0-1)
        quality_score = procedure.get('quality_rating', 3.0) / 5.0

        # Distance score
        distance_score = self.calculate_distance_score(patient.location, procedure['location'])

        # Insurance network score
        network_score = 1.0 if procedure.get('is_in_network', False) else 0.5

        # NEW WEIGHTED COMBINATION - PRIORITIZE RELEVANCE!
        total_score = (
            0.5 * relevance_score +      # 50% relevance (most important!)
            0.2 * cost_score +           # 20% cost
            0.15 * quality_score +       # 15% quality
            0.1 * distance_score +       # 10% distance
            0.05 * network_score         # 5% network
        )

        return total_score

    def recommend_procedures(self, query: str, patient: PatientInfo,
                           top_n: int = 5) -> List[Dict]:
        """Generate top recommendations for a patient's query"""
        # Get cost comparisons
        cost_comparisons = self.cost_engine.compare_costs(query, patient, patient.location)

        # Score each recommendation
        recommendations = []
        for comp in cost_comparisons:
            score = self.score_recommendation(comp, patient)
            recommendation = {
                **comp,
                'recommendation_score': score,
                'recommendation_reason': self._generate_reason(comp, patient)
            }
            recommendations.append(recommendation)

        # Sort by recommendation score
        recommendations.sort(key=lambda x: x['recommendation_score'], reverse=True)

        return recommendations[:top_n]

    def _generate_reason(self, procedure: Dict, patient: PatientInfo) -> str:
        """Generate a human-readable reason for the recommendation"""
        reasons = []

        if procedure.get('is_in_network', False):
            reasons.append("in your insurance network")

        if procedure['quality_rating'] >= 4.0:
            reasons.append("high quality rating")

        if procedure['patient_pays'] < 500:  # Arbitrary threshold
            reasons.append("low out-of-pocket cost")

        if patient.location.lower() in procedure['location'].lower():
            reasons.append("convenient location")

        if not reasons:
            reasons.append("good overall value")

        return f"Recommended due to: {', '.join(reasons)}"

    def suggest_alternatives(self, primary_recommendation: Dict,
                           all_options: List[Dict]) -> List[Dict]:
        """Suggest alternative options like telehealth, generic alternatives, etc."""
        alternatives = []

        # Look for telehealth options
        telehealth_options = [opt for opt in all_options
                            if 'telehealth' in opt.get('specialty', '').lower() or
                            'virtual' in opt.get('provider_name', '').lower()]

        if telehealth_options:
            alternatives.extend(telehealth_options[:2])  # Add top 2 telehealth options

        # Look for community health centers (typically cheaper)
        community_options = [opt for opt in all_options
                           if 'community' in opt.get('provider_name', '').lower() or
                           'clinic' in opt.get('provider_name', '').lower()]

        if community_options:
            alternatives.extend(community_options[:2])  # Add top 2 community options

        # Remove duplicates and limit results
        seen_providers = set()
        unique_alternatives = []
        for alt in alternatives:
            if alt['provider_id'] not in seen_providers:
                seen_providers.add(alt['provider_id'])
                unique_alternatives.append(alt)

        return unique_alternatives[:3]  # Return top 3 alternatives

class HealthcareAIAssistant:
    """
    Main Healthcare AI Assistant that integrates all components
    """

    PARSE_API_URL = "https://parseapi.back4app.com/classes/YourClass"
    APP_ID = "your_app_id"
    REST_API_KEY = "your_rest_api_key"

    headers = {
        "X-Parse-Application-Id": APP_ID,
        "X-Parse-REST-API-Key": REST_API_KEY,
        "Content-Type": "application/json"
    }

    def __init__(self):
        """Initialize the Healthcare AI Assistant with all components"""
        self.vector_db = HealthcareVectorDatabase()
        self.cost_engine = CostComparisonEngine(self.vector_db)
        self.recommendation_engine = RecommendationEngine(self.cost_engine)
        self.sample_data_loaded = False
        logger.info("Healthcare AI Assistant initialized")

    def load_sample_data(self):
        """Load sample healthcare data for demonstration"""
        # Sample procedures
        sample_procedures = [
            HealthcareProcedure("99213", "Office Visit - Established Patient", 150.0, "PROV001",
                              "Houston Medical Center", "Houston, TX", "Primary Care",
                              ["BlueCross", "Aetna", "UnitedHealth"], 4.2),
            HealthcareProcedure("70551", "MRI Brain without Contrast", 1200.0, "PROV002",
                              "Texas Imaging Center", "Houston, TX", "Radiology",
                              ["BlueCross", "UnitedHealth"], 4.5),
            HealthcareProcedure("D0120", "Periodic Oral Evaluation", 80.0, "PROV003",
                              "Smile Dental Clinic", "Houston, TX", "Dentistry",
                              ["Delta Dental", "MetLife"], 4.0),
            HealthcareProcedure("G0439", "Annual Wellness Visit", 200.0, "PROV004",
                              "Community Health Center", "Houston, TX", "Primary Care",
                              ["Medicare", "Medicaid", "BlueCross"], 3.8),
            HealthcareProcedure("29881", "Knee Arthroscopy", 3500.0, "PROV005",
                              "Houston Orthopedic Surgery", "Houston, TX", "Orthopedics",
                              ["BlueCross", "Aetna", "UnitedHealth"], 4.6),
            HealthcareProcedure("80053", "Comprehensive Metabolic Panel", 45.0, "PROV006",
                              "LabCorp", "Houston, TX", "Laboratory",
                              ["Most Insurance Plans"], 4.1),
            HealthcareProcedure("99395", "Preventive Medicine - Adult", 180.0, "PROV007",
                              "Memorial Hermann", "Houston, TX", "Primary Care",
                              ["BlueCross", "Aetna", "UnitedHealth", "Cigna"], 4.3)
        ]

        # Add procedures to vector database
        self.vector_db.add_procedures(sample_procedures)
        self.sample_data_loaded = True
        logger.info("Sample data loaded successfully")

    def create_sample_patient(self, has_insurance: bool = True) -> PatientInfo:
        """Create a sample patient for testing"""
        if has_insurance:
            # Sample insurance plan
            insurance_plan = InsurancePlan(
                plan_id="BC001",
                plan_name="BlueCross Silver Plan",
                deductible=2000.0,
                copay={"Primary Care": 25.0, "Specialist": 50.0, "general": 30.0},
                coinsurance=0.2,  # 20% coinsurance
                out_of_pocket_max=6000.0,
                network_providers=["PROV001", "PROV002", "PROV004", "PROV005", "PROV007"]
            )

            patient = PatientInfo(
                patient_id="PAT001",
                insurance_plan=insurance_plan,
                location="Houston, TX",
                deductible_remaining=1500.0,
                out_of_pocket_remaining=5500.0
            )
        else:
            # Uninsured patient
            patient = PatientInfo(
                patient_id="PAT002",
                insurance_plan=None,
                location="Houston, TX",
                deductible_remaining=0.0,
                out_of_pocket_remaining=0.0
            )

        return patient

    def process_query(self, query: str, patient: PatientInfo) -> Dict[str, Any]:
        """Process a patient's query and return comprehensive recommendations, including CMS data"""
        if not self.sample_data_loaded:
            self.load_sample_data()

        try:
            # Get recommendations from existing engine
            recommendations = self.recommendation_engine.recommend_procedures(
                query, patient, top_n=5
            )

            # --- Integrate CMS ingestion pipeline ---
            try:
                from data_ingestion.module.cms_ingestion.cms_ingestion import ingest_pipeline
                cms_chunks = ingest_pipeline()
                # Filter CMS chunks by query keyword (simple match)
                cms_recs = [chunk for chunk in cms_chunks if query.lower() in chunk.get('text', '').lower()]
            except Exception as cms_e:
                logger.warning(f"CMS ingestion failed: {cms_e}")
                cms_recs = []

            # Combine recommendations
            all_recommendations = recommendations.copy()
            if cms_recs:
                # Format CMS chunks for frontend display
                for chunk in cms_recs:
                    all_recommendations.append({
                        'procedure_name': chunk.get('procedure_name', 'CMS Procedure'),
                        'provider_name': chunk.get('source_name', 'CMS'),
                        'location': chunk.get('location', ''),
                        'patient_pays': chunk.get('cost_avg', ''),
                        'quality_rating': '',
                        'relevance_score': '',
                        'reason': f"Sourced from CMS data. See {chunk.get('source_url', '')}"
                    })

            if not all_recommendations:
                return {"error": "No procedures found for your query"}

            # Get cost summary
            cost_summary = self.cost_engine.generate_cost_summary(all_recommendations)

            # Get alternatives
            alternatives = self.recommendation_engine.suggest_alternatives(
                all_recommendations[0], all_recommendations
            )

            # Format response
            response = {
                "query": query,
                "patient_location": patient.location,
                "has_insurance": patient.insurance_plan is not None,
                "recommendations": all_recommendations,
                "cost_summary": cost_summary,
                "alternatives": alternatives,
                "financial_guidance": self._generate_financial_guidance(
                    all_recommendations[0], patient
                )
            }

            return response

        except Exception as e:
            import traceback
            logger.error(f"Error processing query: {str(e)}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return {"error": f"Failed to process query: {str(e)}", "details": traceback.format_exc()}

    def _generate_financial_guidance(self, best_option: Dict, patient: PatientInfo) -> Dict:
        """Generate personalized financial guidance"""
        guidance = {}

        if patient.insurance_plan:
            guidance["insurance_status"] = f"You have {patient.insurance_plan.plan_name}"
            guidance["deductible_info"] = f"Remaining deductible: ${patient.deductible_remaining:.2f}"
            guidance["network_advice"] = "In-network" if best_option.get('is_in_network') else "Out-of-network"
        else:
            guidance["insurance_status"] = "No insurance detected"
            guidance["cash_pay_advice"] = "Consider asking providers about cash pay discounts"

        guidance["estimated_cost"] = f"${best_option['patient_pays']:.2f}"
        guidance["potential_savings"] = f"${best_option.get('savings_potential', 0):.2f} vs highest option"

        return guidance

    def get_data_from_parse():
         response = requests.get(PARSE_API_URL, headers=headers)
         return response.json()

    def save_data_to_parse(data):
        response = requests.post(PARSE_API_URL, headers=headers, json=data)
        return response.json()

def run_comprehensive_test():
    """Run a comprehensive test of the Healthcare AI Assistant"""
    print("Healthcare AI Assistant - Comprehensive Test")
    print("=" * 60)

    # Initialize the system
    assistant = HealthcareAIAssistant()

    # Create test patients
    insured_patient = assistant.create_sample_patient(has_insurance=True)
    uninsured_patient = assistant.create_sample_patient(has_insurance=False)

    # Test scenarios for insured patient
    print("\nINSURED PATIENT TESTING")
    print("-" * 30)

    insured_scenarios = [
        ("I need an MRI for my brain", "Should find MRI procedure"),
        ("I need knee surgery", "Should find orthopedic surgery"),
        ("I need blood work done", "Should find laboratory tests"),
        ("I need a routine checkup", "Should find office visit or wellness exam")
    ]

    for query, expectation in insured_scenarios:
        print(f"\nQuery: '{query}'")
        print(f"Expected: {expectation}")

        result = assistant.process_query(query, insured_patient)

        if "error" not in result:
            top_rec = result['recommendations'][0]
            print(f"Result: {top_rec['provider_name']} - {top_rec['procedure_name']}")
            print(f"Cost: ${top_rec['patient_pays']:.2f}")
            print(f"Quality: {top_rec['quality_rating']}/5.0")
            print(f"Relevance: {top_rec['relevance_score']:.3f}")
        else:
            print(f"Error: {result['error']}")

    # Test scenarios for uninsured patient
    print("\n\nUNINSURED PATIENT TESTING")
    print("-" * 30)

    uninsured_query = "I need a checkup but have no insurance"
    print(f"\nQuery: '{uninsured_query}'")

    result = assistant.process_query(uninsured_query, uninsured_patient)

    if "error" not in result:
        print("Top 3 cash pay options:")
        for i, rec in enumerate(result['recommendations'][:3], 1):
            print(f"{i}. {rec['provider_name']}: ${rec['patient_pays']:.2f}")

        print(f"\nFinancial Guidance:")
        for key, value in result['financial_guidance'].items():
            print(f"  {key}: {value}")
    else:
        print(f"Error: {result['error']}")

    print("\n" + "=" * 60)
    print("Comprehensive test completed")


# Example usage and testing
if __name__ == "__main__":
    run_comprehensive_test()